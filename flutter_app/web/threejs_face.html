<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    * { margin: 0; padding: 0; }
    body { overflow: hidden; background: transparent; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Three.js 3D Emotional Face
    let scene, camera, renderer;
    let faceGroup;
    let leftEye, rightEye, leftPupil, rightPupil;
    let leftBrow, rightBrow;
    let nose;
    let mouthLine;
    let currentEmotion = {
      happiness: 0.2,
      sadness: 0.1,
      anger: 0.1,
      fear: 0.05,
      surprise: 0.1,
      disgust: 0.05
    };
    let targetEmotion = { ...currentEmotion };

    // Animation
    let blinkTimer = 0;
    let isBlinking = false;
    let blinkProgress = 0;
    let breathTimer = 0;

    init();
    animate();

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x2a2a3a);

      // Camera
      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 4;

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const keyLight = new THREE.DirectionalLight(0xffffff, 0.8);
      keyLight.position.set(3, 3, 5);
      scene.add(keyLight);

      const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
      fillLight.position.set(-3, 0, 3);
      scene.add(fillLight);

      const rimLight = new THREE.DirectionalLight(0xaaccff, 0.3);
      rimLight.position.set(0, 0, -5);
      scene.add(rimLight);

      // Create face
      createFace();

      // Handle resize
      window.addEventListener('resize', onWindowResize);

      // Listen for emotion updates from Flutter
      window.addEventListener('message', handleMessage);
    }

    function createFace() {
      faceGroup = new THREE.Group();

      // Skin material
      const skinMaterial = new THREE.MeshStandardMaterial({
        color: 0xffdbac,
        roughness: 0.6,
        metalness: 0.0
      });

      // Face (head) - sphere
      const faceGeometry = new THREE.SphereGeometry(1, 64, 64);
      const face = new THREE.Mesh(faceGeometry, skinMaterial);
      face.scale.set(1, 1.2, 0.95);
      faceGroup.add(face);

      // Forehead highlight
      const foreheadGeometry = new THREE.SphereGeometry(0.8, 32, 32);
      const foreheadMaterial = new THREE.MeshStandardMaterial({
        color: 0xffe4c4,
        roughness: 0.5,
        metalness: 0.0
      });
      const forehead = new THREE.Mesh(foreheadGeometry, foreheadMaterial);
      forehead.position.set(0, 0.4, 0.3);
      forehead.scale.set(1, 0.6, 0.5);
      faceGroup.add(forehead);

      // Create eyes
      createEyes();

      // Create nose
      createNose();

      // Create mouth
      createMouth();

      // Create eyebrows
      createEyebrows();

      scene.add(faceGroup);
    }

    function createEyes() {
      // Eye socket shadows
      const socketGeometry = new THREE.SphereGeometry(0.22, 32, 32);
      const socketMaterial = new THREE.MeshStandardMaterial({
        color: 0xd4a574,
        roughness: 0.8
      });

      const leftSocket = new THREE.Mesh(socketGeometry, socketMaterial);
      leftSocket.position.set(-0.35, 0.15, 0.75);
      leftSocket.scale.set(1, 0.8, 0.3);
      faceGroup.add(leftSocket);

      const rightSocket = new THREE.Mesh(socketGeometry, socketMaterial);
      rightSocket.position.set(0.35, 0.15, 0.75);
      rightSocket.scale.set(1, 0.8, 0.3);
      faceGroup.add(rightSocket);

      // Eyeballs (white)
      const eyeGeometry = new THREE.SphereGeometry(0.15, 32, 32);
      const eyeMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.1
      });

      leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.35, 0.15, 0.85);
      leftEye.scale.set(1, 1, 0.6);
      faceGroup.add(leftEye);

      rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.35, 0.15, 0.85);
      rightEye.scale.set(1, 1, 0.6);
      faceGroup.add(rightEye);

      // Irises
      const irisGeometry = new THREE.CircleGeometry(0.08, 32);
      const irisMaterial = new THREE.MeshStandardMaterial({
        color: 0x4a6741,
        roughness: 0.3
      });

      const leftIris = new THREE.Mesh(irisGeometry, irisMaterial);
      leftIris.position.set(-0.35, 0.15, 0.95);
      faceGroup.add(leftIris);

      const rightIris = new THREE.Mesh(irisGeometry, irisMaterial);
      rightIris.position.set(0.35, 0.15, 0.95);
      faceGroup.add(rightIris);

      // Pupils
      const pupilGeometry = new THREE.CircleGeometry(0.04, 32);
      const pupilMaterial = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.2
      });

      leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
      leftPupil.position.set(-0.35, 0.15, 0.96);
      faceGroup.add(leftPupil);

      rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
      rightPupil.position.set(0.35, 0.15, 0.96);
      faceGroup.add(rightPupil);

      // Eye highlights
      const highlightGeometry = new THREE.CircleGeometry(0.02, 16);
      const highlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

      const leftHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
      leftHighlight.position.set(-0.32, 0.18, 0.97);
      faceGroup.add(leftHighlight);

      const rightHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
      rightHighlight.position.set(0.38, 0.18, 0.97);
      faceGroup.add(rightHighlight);
    }

    function createNose() {
      // Nose bridge
      const bridgeGeometry = new THREE.BoxGeometry(0.12, 0.35, 0.15);
      const noseMaterial = new THREE.MeshStandardMaterial({
        color: 0xeac086,
        roughness: 0.6
      });
      const bridge = new THREE.Mesh(bridgeGeometry, noseMaterial);
      bridge.position.set(0, -0.05, 0.9);
      faceGroup.add(bridge);

      // Nose tip (ball)
      const tipGeometry = new THREE.SphereGeometry(0.1, 32, 32);
      nose = new THREE.Mesh(tipGeometry, noseMaterial);
      nose.position.set(0, -0.2, 0.95);
      nose.scale.set(1, 0.8, 0.8);
      faceGroup.add(nose);

      // Nostrils
      const nostrilGeometry = new THREE.SphereGeometry(0.04, 16, 16);
      const nostrilMaterial = new THREE.MeshStandardMaterial({
        color: 0x3d2020,
        roughness: 0.8
      });

      const leftNostril = new THREE.Mesh(nostrilGeometry, nostrilMaterial);
      leftNostril.position.set(-0.06, -0.25, 0.92);
      faceGroup.add(leftNostril);

      const rightNostril = new THREE.Mesh(nostrilGeometry, nostrilMaterial);
      rightNostril.position.set(0.06, -0.25, 0.92);
      faceGroup.add(rightNostril);
    }

    function createMouth() {
      // Create mouth using tube geometry
      updateMouth(0);
    }

    function updateMouth(smileAmount) {
      // Remove old mouth if exists
      if (mouthLine) {
        faceGroup.remove(mouthLine);
        mouthLine.geometry.dispose();
      }

      // Create curved path for mouth
      const mouthWidth = 0.35;
      const curveHeight = smileAmount * 0.12;

      const curve = new THREE.QuadraticBezierCurve3(
        new THREE.Vector3(-mouthWidth, -0.5, 0.88),
        new THREE.Vector3(0, -0.5 + curveHeight, 0.92),
        new THREE.Vector3(mouthWidth, -0.5, 0.88)
      );

      // Create tube for 3D mouth
      const tubeGeometry = new THREE.TubeGeometry(curve, 32, 0.025, 12, false);
      const mouthMaterial = new THREE.MeshStandardMaterial({
        color: 0xcc6666,
        roughness: 0.4
      });

      mouthLine = new THREE.Mesh(tubeGeometry, mouthMaterial);
      faceGroup.add(mouthLine);

      // Add upper lip
      const upperLipCurve = new THREE.QuadraticBezierCurve3(
        new THREE.Vector3(-0.2, -0.45, 0.89),
        new THREE.Vector3(0, -0.43, 0.93),
        new THREE.Vector3(0.2, -0.45, 0.89)
      );
      const upperLipGeometry = new THREE.TubeGeometry(upperLipCurve, 20, 0.02, 8, false);
      const upperLipMaterial = new THREE.MeshStandardMaterial({
        color: 0xdd8888,
        roughness: 0.5
      });
      const upperLip = new THREE.Mesh(upperLipGeometry, upperLipMaterial);
      mouthLine.add(upperLip);

      // Open mouth for surprise
      if (currentEmotion.surprise > 0.25) {
        const openAmount = (currentEmotion.surprise - 0.25) * 0.8;
        const mouthOpenGeometry = new THREE.SphereGeometry(0.08 + openAmount * 0.06, 32, 32);
        mouthOpenGeometry.scale(2, 1 + openAmount * 0.5, 0.4);
        const mouthOpenMaterial = new THREE.MeshStandardMaterial({
          color: 0x2a1515,
          roughness: 0.9
        });
        const mouthOpen = new THREE.Mesh(mouthOpenGeometry, mouthOpenMaterial);
        mouthOpen.position.set(0, -0.5 - openAmount * 0.05, 0.85);
        mouthLine.add(mouthOpen);
      }
    }

    function createEyebrows() {
      const browGeometry = new THREE.BoxGeometry(0.25, 0.04, 0.06);
      browGeometry.translate(0.125, 0, 0); // Pivot from inner edge

      const browMaterial = new THREE.MeshStandardMaterial({
        color: 0x4a3728,
        roughness: 0.8
      });

      // Left eyebrow (pivots from right side - inner edge)
      leftBrow = new THREE.Mesh(browGeometry, browMaterial);
      leftBrow.position.set(-0.48, 0.38, 0.82);
      faceGroup.add(leftBrow);

      // Right eyebrow (mirrored, pivots from left side - inner edge)
      const rightBrowGeometry = new THREE.BoxGeometry(0.25, 0.04, 0.06);
      rightBrowGeometry.translate(-0.125, 0, 0);
      rightBrow = new THREE.Mesh(rightBrowGeometry, browMaterial);
      rightBrow.position.set(0.48, 0.38, 0.82);
      faceGroup.add(rightBrow);
    }

    function handleMessage(event) {
      try {
        const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
        if (data.type === 'setEmotion') {
          targetEmotion = {
            happiness: data.happiness || 0,
            sadness: data.sadness || 0,
            anger: data.anger || 0,
            fear: data.fear || 0,
            surprise: data.surprise || 0,
            disgust: data.disgust || 0
          };
        }
      } catch (e) {
        // Ignore parse errors from other messages
      }
    }

    // Global function for Flutter to call
    window.setEmotion = function(emotionJson) {
      try {
        const data = typeof emotionJson === 'string' ? JSON.parse(emotionJson) : emotionJson;
        targetEmotion = {
          happiness: data.happiness || 0,
          sadness: data.sadness || 0,
          anger: data.anger || 0,
          fear: data.fear || 0,
          surprise: data.surprise || 0,
          disgust: data.disgust || 0
        };
      } catch (e) {
        console.error('setEmotion error:', e);
      }
    };

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function animate() {
      requestAnimationFrame(animate);

      const deltaTime = 0.016;

      // Smooth transition to target emotion
      const speed = 2.5 * deltaTime;
      currentEmotion.happiness = lerp(currentEmotion.happiness, targetEmotion.happiness, speed);
      currentEmotion.sadness = lerp(currentEmotion.sadness, targetEmotion.sadness, speed);
      currentEmotion.anger = lerp(currentEmotion.anger, targetEmotion.anger, speed);
      currentEmotion.fear = lerp(currentEmotion.fear, targetEmotion.fear, speed);
      currentEmotion.surprise = lerp(currentEmotion.surprise, targetEmotion.surprise, speed);
      currentEmotion.disgust = lerp(currentEmotion.disgust, targetEmotion.disgust, speed);

      // Apply emotions
      applyEmotions();

      // Blinking
      blinkTimer += deltaTime;
      if (!isBlinking && blinkTimer > 2.5 + Math.random() * 2) {
        isBlinking = true;
        blinkProgress = 0;
        blinkTimer = 0;
      }

      if (isBlinking) {
        blinkProgress += deltaTime * 10;
        if (blinkProgress >= 1) {
          isBlinking = false;
          blinkProgress = 0;
        }
      }

      // Subtle idle animation
      breathTimer += deltaTime;
      if (faceGroup) {
        faceGroup.rotation.y = Math.sin(breathTimer * 0.3) * 0.02;
        faceGroup.position.y = Math.sin(breathTimer * 0.5) * 0.01;
      }

      renderer.render(scene, camera);
    }

    function applyEmotions() {
      // Smile/frown calculation
      const smileAmount = currentEmotion.happiness - currentEmotion.sadness * 0.8 - currentEmotion.anger * 0.5;

      // Update mouth shape
      updateMouth(smileAmount);

      // Eyebrow expressions
      if (leftBrow && rightBrow) {
        // Base height
        let browHeight = 0.38;

        // Raise for surprise/fear
        browHeight += currentEmotion.surprise * 0.1;
        browHeight += currentEmotion.fear * 0.08;

        // Lower for anger
        browHeight -= currentEmotion.anger * 0.06;

        // Inner brow raise for sadness (inverted V shape)
        const sadBrowAngle = currentEmotion.sadness * 0.25;
        const angryBrowAngle = currentEmotion.anger * 0.2;

        leftBrow.position.y = browHeight + currentEmotion.sadness * 0.05;
        rightBrow.position.y = browHeight + currentEmotion.sadness * 0.05;

        // Rotation: positive = inner edge up (sad), negative = inner edge down (angry)
        leftBrow.rotation.z = sadBrowAngle - angryBrowAngle;
        rightBrow.rotation.z = -(sadBrowAngle - angryBrowAngle);
      }

      // Eye expressions
      if (leftEye && rightEye) {
        // Blink effect
        const blinkFactor = isBlinking ? Math.sin(blinkProgress * Math.PI) : 0;
        let eyeOpenness = 1 - blinkFactor * 0.9;

        // Surprise opens eyes wide
        eyeOpenness += currentEmotion.surprise * 0.2;

        // Anger squints eyes
        eyeOpenness -= currentEmotion.anger * 0.25;

        // Fear slightly widens
        eyeOpenness += currentEmotion.fear * 0.1;

        eyeOpenness = Math.max(0.1, Math.min(1.3, eyeOpenness));

        leftEye.scale.y = eyeOpenness;
        rightEye.scale.y = eyeOpenness;
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
